var documenterSearchIndex = {"docs":
[{"location":"#BitPacking","page":"Home","title":"BitPacking","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BitPacking.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#BitPacking.BitPackedArray","page":"Home","title":"BitPacking.BitPackedArray","text":"BitPackedArray{W,T,N,P<:AbstractArray{UInt8,N}} <: AbstractArray{T,N}\n\nA wrapper for an array of packed bytes.\n\nUse bitpacked to create a BitPackedArray, and bitunpacked to unpack it.\n\nwarning: Warning\nBitPackedArray has limited indexing support.\n\n\n\n\n\n","category":"type"},{"location":"#BitPacking.bitpacked","page":"Home","title":"BitPacking.bitpacked","text":"bitpacked(x::AbstractArray, W=bitwidth(T))\n\nReturns a BitPackedArray of the same size as x, with each element packed into W bits.\n\nbitpacked is a no-op if x is already a BitPackedArray with the same bitwidth.\n\nExamples\n\njulia> x = rand(Bool, 8, 2);\n\njulia> packed = bitpacked(x, 1);\n\njulia> packed == x\ntrue\n\njulia> packed .= [true false];\n\njulia> all(packed[:,1])\ntrue\n\njulia> !any(packed[:,2])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#BitPacking.bitunpacked","page":"Home","title":"BitPacking.bitunpacked","text":"bitunpacked(x::BitPackedArray)\n\nReturns an array of the same size as x, with each element unpacked from W bits.\n\n\n\n\n\n","category":"function"},{"location":"#BitPacking.bitwidth","page":"Home","title":"BitPacking.bitwidth","text":"bitwidth(T::Type)\n\nReturns the number of used bits in T.\n\nThe bit representation of T is expected to not take on any value equal to or greater than 2^bitwidth(T). For example, a 1-bit type should be limited to 0b00000000 and 0b00000001.\n\nExamples\n\njulia> bitwidth(UInt8)\n8\n\njulia> bitwidth(Bool)\n1\n\n\n\n\n\n","category":"function"},{"location":"#BitPacking.packbits","page":"Home","title":"BitPacking.packbits","text":"packbits(w::Int, x::AbstractArray; groups::Val=Val(1))\n\nReturns a BitPackedArray of the same size as x, with each element packed into W bits per element.\n\nSee also packbits!, unpackbits!, unpackbits.\n\n\n\n\n\n","category":"function"},{"location":"#BitPacking.packbits!","page":"Home","title":"BitPacking.packbits!","text":"packbits!(w::Int, packed_bytes::AbstractArray{UInt8}, x::AbstractArray; groups::Val=Val(1))\n\nMutates packed_bytes in-place to pack x into W bits per element.\n\nThe keyword argument groups can be increased to improve performance, while limiting the allowed sizes of the first dimension of x.\n\nSee also packbits, unpackbits!, unpackbits.\n\n\n\n\n\n","category":"function"},{"location":"#BitPacking.unpackbits","page":"Home","title":"BitPacking.unpackbits","text":"unpackbits(w::Int, packed_bytes::AbstractArray{UInt8}, T::Type=UInt8; groups::Val=Val(1))\n\nReturns an array of the same size as packed_bytes, into byte-sized elements of type T.\n\nSee also packbits!, packbits, unpackbits!.\n\n\n\n\n\n","category":"function"},{"location":"#BitPacking.unpackbits!","page":"Home","title":"BitPacking.unpackbits!","text":"unpackbits!(w::Int, x::AbstractArray, packed_bytes::AbstractArray{UInt8}; groups::Val=Val(1))\n\nMutates x in-place to unpack packed_bytes into byte-sized elements of type eltype(x).\n\nThe keyword argument groups can be increased to improve performance, while limiting the allowed sizes of the first dimension of x.\n\nSee also packbits!, packbits, unpackbits.\n\n\n\n\n\n","category":"function"}]
}
